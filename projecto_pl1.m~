
%% PART 1
% load data
% read_raw_data

% load labels
all_labels = importfile('HAPT Data Set/RawData/labels.txt', '%f%f%f%f%f%[^\n\r]');
figure(4)
for acc_file = {{'01','01'}, {'02','01'}, {'03','02'}, {'04','02'}, {'05','03'}, {'06','03'}, {'07','04'}, {'08','04'}, {'09','05'}, {'10','05'}}
    exp = acc_file{1}{1};
    user = acc_file{1}{2};
    fileName = sprintf('acc_exp%s_user%s.txt', exp, user)
    dacc = importfile(['HAPT Data Set/RawData/' fileName], '%f%f%f%[^\n\r]');
    
    % get labels for current file
    %ix_labels=intersect(find(all_labels(:,1)==str2num(Expr)), find(all_labels(:,2)==str2num(User{u})))
    ix_labels=intersect(find(all_labels(:,1)==str2num(exp)), find(all_labels(:,2)==str2num(user))); %exp 01 user 01

    data = dacc;
    % time vector
    Fs = 50; %hz
    activities={'W','WU','WD','S','ST','L','ST','SS','SL','LS','STL','LTS'};
    t=[0:size(data,1)-1]./Fs;

    % data size
    [n_points, n_plots]=size(data);

    % fazer plot
%{    
    figure(1)
    for i=1:n_plots
        subplot(n_plots,1,i); plot(t./60,data(:,i),'k--')
        % axis[0 t[end]./60 min(data(:,i)) nax(data(:,i))]
        % xlabel('time in min')
        hold on
        for j=1:numel(ix_labels)
            plot(t(all_labels(ix_labels(j),4):all_labels(ix_labels(j),5))./60,data(all_labels(ix_labels(j),4): all_labels(ix_labels(j),5),i))
            if (mod(j,2)==1)
                ypos=min(data(:,i))-(0.2*min(data(:,i)));
            else
                ypos=max(data(:,i))-(0.2*max(data(:,i)));
            end
            % nao est?? a adicionar as labels:
            %text(t(all_labels(ix_labels(j),4))/60,ypos,activities{all_labels(ix_labels(j),3)}, 'for ');
        end
    end
    % for j=1:numel(ix_labels) ciclo sobre ix_labels 
        % plot do tempo para os intervalos a q corresponde
        % text( com a anotacao correspondente
        %if mod(j,2)==1 % 
        %    ypos=min(
        %else
        %    ypos=max(
        %end

     % Part 2


     for i = 1:3

     end

    %% ex. 4.1
    % calcular DFT
    %clear all

    %figure(2); % all plots on same drawing

for j=1:numel(ix_labels)
    %j=13; % signal segment / activity; exp01: 1=STANDING, 2=STAND_TO_SIT, 3=SITTING, 13-16=Walking, 18,20=WALKING_UPSTAIRS...
    % i=3; % x,y,z axis
    for i = 1:3 % i=axis
        close all
        figure(i+1);

        activity = data(all_labels(ix_labels(j),4): all_labels(ix_labels(j),5),i);
        activity_label = activities{all_labels(ix_labels(j),3)};
        N = numel(activity);

        % calcular vector de frequencias
        %if (mod(N,2)==0)
            % se numero de pontos de pontos do sinal for par
        %    f = -Fs/2:Fs/N:Fs/2-Fs/N;
        %else
             % se numero de pontos de pontos do sinal for impar
        %    f = -Fs/2+Fs/(2*N):Fs/N:Fs/2-Fs/(2*N);
        %end

        % janelas disponiveis ver https://www.mathworks.com/help/dsp/ref/windowfunction.html

        windows = [rectwin(N) blackman(N) hamming(N) hann(N)]; % other:  taylorwin(N) bartlett(N)...
        windows_names = {'rectwin' 'blackman' 'hamming' 'hann'};

        current_axis = {'X' 'Y' 'Z'};

        %X = fftshift(fft(activity)); % DFT do sinal sem janela
        [f,X] = my_fft(activity,Fs);

        subplot(321)
        plot(f,activity), hold on
        title(['Sinal original - ' current_axis{i} ' axis - ' activity_label]);
        ylabel('?')
        xlabel('t [??]')
        %axis tight

        subplot(322)
        plot(f,abs(X)), hold on
        title('|DFT| do sinal sem janela');
        ylabel('Magnitude = |X|')
        xlabel('f [Hz]')
        %axis tight

        % itera sobre as janelas definidas em cima
        for w=1:size(windows,2)
            %wvtool(windows(:,w)) % visualizar janela usada
            %X = fftshift(fft(activity.*windows(:,i))); % DFT do sinal com janela
            [f,X] = my_fft(activity.*windows(:,w),Fs); % my_fft func das PL
            subplot(3,2,w+2)
            plot(f,abs(X)), hold on
            title(['DFT do Sinal - ' activity_label ' - ' windows_names{w}]);
            ylabel('Magnitude = |X|')
            xlabel('f [Hz]')
            %axis tight
        end


        saveas(figure(i+1), [pwd, '/exports/export_' num2str(j) '_' activity_label '_' current_axis{i} '_' fileName '.pdf']);

    end
end
%}

%% 4.2
%{
%primeira implementacao abordado os 3 eixos em simultaneo
numeroElementos=0;
total=0;
for k=1:numel(ix_labels)
    if all_labels(ix_labels(k),3) < 4
        %vai carregar a informacao dos 3 eixos e calcular a respectiva dft
        x=data(all_labels(ix_labels(k),4): all_labels(ix_labels(k),5),1);
        xdft=fftshift(fft(x));
        %f=linspace(-25,25,numel(x));
        
        y=data(all_labels(ix_labels(k),4): all_labels(ix_labels(k),5),2);
        ydft=fftshift(fft(y));
        %f=linspace(-25,25,numel(y));
        
        z=data(all_labels(ix_labels(k),4): all_labels(ix_labels(k),5),3);
        zdft=fftshift(fft(z));
        %f=linspace(-25,25,numel(x));
        
        %associa a informacao dos 3 eixos numa so funcao "mag"
        mag = sqrt(sum(xdft.^2 + ydft.^2 + zdft.^2, 2));
        %delimita o ponto medio para de seguida determinar os picos
        magNoG = mag - mean(mag);
        minPeakHeight = std(magNoG);
        [pks, locs] = findpeaks(abs(mag), 'MINPEAKHEIGHT', minPeakHeight);
        %determina a frequencia do primeiro pico e multiplica pelo tempo 60s
        %mag(locs(1))*60
        total=total+ (mag(locs(1))*60);
        numeroElementos=numeroElementos+1;
    end
end
media=total/numeroElementos
%}
%segunda implementacao aboradando agora apenas o eixo dos z's nao esta a
%funcionar
numeroElementos1=0;
total1=0;
for k=1:numel(ix_labels)
    if all_labels(ix_labels(k),3) < 4
        x=data(all_labels(ix_labels(k),4): all_labels(ix_labels(k),5),3);
        magNoG1 = xdft - mean(xdft);
        minPeakHeight = std(magNoG1);
        [pks1,locs] = findpeaks(x,'MINPEAKHEIGHT', minPeakHeight);
        if numel(pks1) > 0
            x(locs(1))* 60;
            %guardar num array e chamr std no fim
            total1=total1+ x(locs(1))*60;
            numeroElementos1=numeroElementos1+1;
        else
            k 
            disp('error calculating peaks')
        end
    end
end
media1=total1/numeroElementos1;
%faltam em ambos os casos o desvio padrao

%{
%% 4.3
picsX = zeros(numel(ix_labels),1);
picsY= zeros(numel(ix_labels),1);
picsZ= zeros(numel(ix_labels),1);
for k=1:numel(ix_labels)
    %vai carregar a informacao dos 3 eixos
    x=data(all_labels(ix_labels(k),4): all_labels(ix_labels(k),5),1);
    y=data(all_labels(ix_labels(k),4): all_labels(ix_labels(k),5),2);
    z=data(all_labels(ix_labels(k),4): all_labels(ix_labels(k),5),3);
   
    %delimita o ponto medio para de seguida determinar os picos
    %x

    magNoG = x - mean(x);
    minPeakHeight = std(x);
    [pks, locs] = findpeaks(magNoG, 'MINPEAKHEIGHT', minPeakHeight);
    if numel(locs) > 0
        picsX(k)= x(locs(1));  
    end
    
    %y
    magNoG = y - mean(y);
    minPeakHeight = std(y);
    [pks, locs] = findpeaks(magNoG, 'MINPEAKHEIGHT', minPeakHeight);
    if numel(locs) > 0
        picsY(k)= y(locs(1));  
    end
    %z
    magNoG = z - mean(z);
    minPeakHeight = std(z);
    [pks, locs] = findpeaks(magNoG, 'MINPEAKHEIGHT', minPeakHeight);
    if numel(locs) > 0
        picsZ(k)= z(locs(1));  
    end

end

XDin=picsX(13:numel(picsX))
YDin=picsY(13:numel(picsX))
ZDin=picsZ(13:numel(picsX))
XStat=picsX(1:12)
YStat=picsY(1:12)
ZStat=picsZ(1:12)

hold on
scatter3(XDin,YDin,ZDin, 'r', 'filled')

scatter3(XStat,YStat,ZStat, 'b', 'filled')



    %% ex. 5.
    % Freq/Time min |Power
    % STFT no eixo Z para um ficheiro de dados ?? escolha
    %{ 
    i = 3; %eixo z
    j = 13; %activity
    activity = data(all_labels(ix_labels(j),4): all_labels(ix_labels(j),5),i);

    Tframe= 0.128; %largura da janela em analise em s
    Toverlap = 0.064; % sobreposi????o das janelas em s
    Nframe= round(Tframe*Fs); %numero de amostras na janela
    Noverlap = round(Toverlap*Fs); % numero de amostras sobrepostas

    h = hamming(Nframe); % janela de hamming

    if mod(Nframe, 2)==0
        f_frame = -Fs/2:Fs/Nframe:Fs/2-Fs/Nframe;
    else
        f_frame = -Fs/2+Fs/(2*Nframe):Fs/Nframe:Fs/2-Fs/(2*Nframe);
    end

    % itera sobre sinal da actividade com janelas sobrepostas
    for ii = 1:Nframe-Noverlap:N-Nframe
        % aplicar a janela ao sinal do tempo
        x_frame = activity(ii:ii+Nframe-1).*h;

        % ver na fp 9...
    end
    %}
%}
end


hold off
grid on


